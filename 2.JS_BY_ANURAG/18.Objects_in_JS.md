Alright â€” this is a **big, important video**, and you did the right thing by asking for a **full, clean explanation**.
Iâ€™ll teach **everything thatâ€™s taught**, but **clearly, step-by-step**, without the confusion, repetition, or blackboard chaos.

This lesson is about **NON-PRIMITIVE (REFERENCE) TYPES**, especially **OBJECTS**, and **WHY memory addresses matter here**.

---

# ğŸ§  JavaScript Non-Primitive Data Types (Objects) â€” COMPLETE EXPLANATION

---

## 1ï¸âƒ£ Primitive vs Non-Primitive (Value vs Reference)

### JavaScript has **ONLY 8 data types**

### âœ… Primitive (Value Types) â€” 7

* Number
* String
* Boolean
* Undefined
* Null
* BigInt
* Symbol

ğŸ“Œ These are called **value types**
ğŸ“Œ Their **addresses are usually not important**

---

### âœ… Non-Primitive (Reference Type) â€” 1

* **Object**

ğŸ“Œ Only **ONE non-primitive type exists**
ğŸ“Œ Arrays, functions, dates, etc. are **ALL objects internally**

---

## 2ï¸âƒ£ Why â€œReference Typeâ€?

Because **variables donâ€™t store values**
They store **ADDRESS (reference) of the object**

ğŸ‘‰ This is why objects behave differently from primitives.

---

## 3ï¸âƒ£ Creating an Object (Object Literal)

```js
const user = {};
```

* `{}` creates an **empty object**
* This is **NOT a block**
* When `{}` is written after `=`, JS treats it as an object

ğŸ“Œ This object is created **somewhere in memory**
ğŸ“Œ `user` stores the **address of that object**

---

## 4ï¸âƒ£ Keyâ€“Value Pairs in Objects

```js
const user = {
  firstName: "Akash",
  lastName: "Singh",
  age: 26,
  education: 12,
  city: "Bangalore"
};
```

### Terminology

* `firstName` â†’ **key**
* `"Akash"` â†’ **value**
* Together â†’ **keyâ€“value pair**

ğŸ“Œ Objects store **multiple keyâ€“value pairs**

---

## 5ï¸âƒ£ Formatting Objects (Best Practice)

* Small object â†’ single line OK
* Big object â†’ **multi-line (readability)**

```js
const user = {
  firstName: "Akash",
  lastName: "Singh",
  age: 26
};
```

Formatter (`Shift + Alt + F`) auto-formats large objects.

---

## 6ï¸âƒ£ Accessing Object Values

### âœ… Dot Notation (MOST COMMON)

```js
user.firstName; // "Akash"
user.age;       // 26
```

---

### âœ… Bracket Notation

```js
user["firstName"]; // "Akash"
user["age"];       // 26
```

ğŸ“Œ **Keys are internally strings**
ğŸ“Œ Dot notation is just a shortcut

---

## 7ï¸âƒ£ Why Bracket Notation is POWERFUL ğŸ”¥

### Case 1: Invalid Key Names

```js
const user = {
  "last-name": "Singh"
};
```

âŒ Dot notation fails:

```js
user.last-name; // error
```

âœ… Bracket notation works:

```js
user["last-name"]; // "Singh"
```

---

### Case 2: Using JavaScript Variables

```js
const key = "firstName";

user[key]; // "Akash"
```

âŒ This DOES NOT work:

```js
user.key; // undefined
```

ğŸ“Œ Because dot notation looks for literal `"key"`

---

### Case 3: Using Expressions

```js
user["first" + "Name"]; // "Akash"
```

ğŸ“Œ Bracket notation **evaluates JavaScript code**
ğŸ“Œ Dot notation **does not**

---

## 8ï¸âƒ£ Accessing Non-Existing Keys

```js
user.salary; // undefined
user["salary"]; // undefined
```

ğŸ“Œ Objects return `undefined` for missing keys (NO error)

---

## 9ï¸âƒ£ Updating / Adding Properties

### Add new property

```js
user.age = 26;
```

or

```js
user["age"] = 26;
```

---

### Important Concept âš ï¸

* Object is updated **in memory**
* Source code doesnâ€™t change
* Reload page â†’ changes disappear (unless written in code)

---

## ğŸ”Ÿ Objects Are Reference Types (CORE CONCEPT)

### Example

```js
const user1 = {};
const user2 = {};
```

They look same âŒ
Butâ€¦

```js
user1 === user2; // false
```

### WHY?

Because:

```
user1 â†’ address A
user2 â†’ address B
```

ğŸ“Œ JavaScript compares **addresses**, NOT values

---

## 1ï¸âƒ£1ï¸âƒ£ Compare With Primitive Types

```js
const a = "";
const b = "";
```

```js
a === b; // true
```

âœ” Same value
âœ” Same address (primitive optimization)

---

But:

```js
const x = {};
const y = {};
```

```js
x === y; // false
```

âŒ Different addresses

---

## 1ï¸âƒ£2ï¸âƒ£ Why JS Does NOT Compare Object Values

Because objects can be **HUGE**:

* Shopping cart
* User profile
* Orders
* Products
* Nested data (1000s of keys)

ğŸ“Œ Comparing every value would be **slow**
ğŸ“Œ So JS compares **only address**

---

## 1ï¸âƒ£3ï¸âƒ£ Nested Objects (Object Inside Object)

```js
const user = {
  firstName: "Adarsh",
  lastName: "Singh",
  address: {
    city: "Bangalore",
    pincode: 560001,
    state: "Karnataka"
  }
};
```

ğŸ“Œ `address` itself is an **object**
ğŸ“Œ A **NEW object** is created in memory
ğŸ“Œ Its **address** is stored inside `user`

---

## 1ï¸âƒ£4ï¸âƒ£ Accessing Nested Objects

```js
user.address.city;      // "Bangalore"
user.address.pincode;   // 560001
user.address.state;     // "Karnataka"
```

Or using brackets:

```js
user["address"]["city"];
```

---

## 1ï¸âƒ£5ï¸âƒ£ Deep Nesting (Object in Object in Object)

```js
const user = {
  address: {
    moreDetails: {
      population: 10000000,
      area: "741 sq km"
    }
  }
};
```

ğŸ“Œ Every `{}` creates a **NEW object**
ğŸ“Œ Every object has its **own address**
ğŸ“Œ Objects are **connected via addresses**

---

## 1ï¸âƒ£6ï¸âƒ£ Updating Nested Objects

```js
user.address.moreDetails.weather = "Nice";
```

âœ” Updates the object in memory
âœ” No new object created
âœ” Same address, updated value

---

## 1ï¸âƒ£7ï¸âƒ£ Memory Visualization (Mental Model)

```
Variable (user)
   â†“
Address (A1)
   â†“
Object {
  firstName,
  lastName,
  address â†’ Address (A2)
}

Address (A2)
   â†“
Object {
  city,
  pincode,
  moreDetails â†’ Address (A3)
}

Address (A3)
   â†“
Object {
  population,
  area
}
```

ğŸ“Œ Objects are **NOT inside objects**
ğŸ“Œ They live separately in memory
ğŸ“Œ Only **addresses connect them**

---

## 1ï¸âƒ£8ï¸âƒ£ Why This Matters (VERY IMPORTANT)

### This explains:

* Why `{} === {}` is false
* Why copying objects causes bugs
* Why arrays behave strangely
* Why functions are reference types
* Why mutations affect original objects

ğŸ‘‰ This is the **foundation of real JavaScript**

---

## 1ï¸âƒ£9ï¸âƒ£ Final Takeaways (MEMORIZE)

âœ… JavaScript has **1 non-primitive type: Object**
âœ… Objects are **reference types**
âœ… Variables store **addresses**, not objects
âœ… `{}` always creates a **new object**
âœ… Object comparison = **address comparison**
âœ… Nested objects = **multiple objects in memory**
âœ… Dot notation = simple access
âœ… Bracket notation = powerful & dynamic

---

## ğŸš€ What Comes Next (Natural Progression)

Next topics will make **much more sense now**:

* Arrays (also objects)
* Functions (also objects)
* Object copying
* Shallow vs deep copy
* Reference bugs
* `const` with objects
* Mutation vs immutability

If you want, I can:

* ğŸ”¥ Teach **arrays using same memory model**
* ğŸ§  Explain **why changing one object affects another**
* ğŸ’¥ Explain **real interview questions**
* ğŸ§ª Give **practice problems**
* ğŸ“˜ Convert this into **Markdown notes**

Just tell me what you want next ğŸ‘Š
